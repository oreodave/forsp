#+title: Forsp tasks
#+filetags: c forsp

* Resources
- Article: https://xorvoid.com/forsp.html
- Repo: https://github.com/xorvoid/forsp
- [[~/Code/ThirdParty/forsp/forsp.c]]

* TODO Backlog
** TODO Do we need better errors?
[[file:src/obj.c]]
[[file:src/parser.c]]
Currently we use ~FAIL~ to stop on a critical error.  This is used in
parsing - which can be forgiven for hard stops - and the object API.
This is nice, but if we want to introduce more powerful features (like
being able to catch and deal with errors in the actual language) we'll
need a centralised approach to this.  FAIL isn't catchable.

We also need a way to propagate errors through potentially many layers
of recursion - perhaps even adding info at each pass step.
** TODO Can we make a better abstraction for environments?
[[file:include/obj.h::// Environments]]
An environment is an ALIST.  This is okay, but not great - O(n) time
to search stuff up.  Furthermore, _every_ time we set something, the
environment alist grows - this is bad for long term performance.

It makes lexical environments trivial, which is nice.  We need
something better though.
** TODO stream_init_cstr
[[file:include/parser.h]]
Create a new stream from a CString passed in.  Makes testing easier
and adds an avenue for better testing.
* TODO Memory Management :gc:
We need a better memory management scheme for our heap allocated
stuff.

We currently maintain a vector of allocated objects, which is appended
to every time we allocate something to the heap as part of our
~make_*~ functions.  This is all cleaned up in ~state_delete~, which
is only really called at the end of the program.  In practice, this
means we don't really do any proactive collection of memory - which
means the memory footprint of the program will grow indefinitely
despite there being situations where we could reasonably clean memory.

I'd like to implement a tracing GC strategy, so-called mark/sweep:
- Consider all objects unmarked at the start of the procedure
- Mark all "root" objects (immediately accessible via the environment)
  then recursively mark any sub-objects of them
- Iterate through all unmarked objects and clean them

This way we'll only clean the objects that are actually accessible by
the program at any small time interval.
** TODO Consider the structure for memory allocation
Our current memory allocation strategy just uses ~malloc~ at the point
of creation.  ~malloc~ is great and all, but it's also really slow.  I
think we should implement a custom allocator, such as an ~arena~.

Pros:
- Allows us to /defragment/ memory space to make lookups faster
- Less calls to ~malloc~
- Custom pointer type which we can tag effectively

Cons:
- Memory lookup is a bit more involved; we need to first reference our
  arena
** TODO Consider how we select root objects to mark
* TODO Closures :closures:
[[file:include/obj.h]]
[[file:src/obj.c]]
** TODO Write parser
[[file:src/parser.c]]
* TODO Primitives :primitives:
** TODO Write API
[[file:include/obj.h]]
[[file:src/obj.c]]
** TODO Write parser
[[file:src/parser.c]]
* TODO Compute/evaluate
