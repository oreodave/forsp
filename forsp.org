#+title: Forsp tasks
#+filetags: c forsp

* Resources
- Article: https://xorvoid.com/forsp.html
- Repo: https://github.com/xorvoid/forsp
- [[~/Code/ThirdParty/forsp/forsp.c]]

* TODO Closures :closures:
** TODO Write API
[[file:include/obj.h]]
[[file:src/obj.c]]
** TODO Write parser
[[file:src/parser.c]]
* TODO Primitives :primitives:
** TODO Write API
[[file:include/obj.h]]
[[file:src/obj.c]]
** TODO Write parser
[[file:src/parser.c]]
* TODO Compute/evaluate
* TODO Backlog
** TODO Do we need better errors?
[[file:src/obj.c]]
[[file:src/parser.c]]
Currently we use ~FAIL~ to stop on a critical error.  This is used in
parsing - which can be forgiven for hard stops - and the object API.
This is nice, but if we want to introduce more powerful features (like
being able to catch and deal with errors in the actual language) we'll
need a centralised approach to this.  FAIL isn't catchable.

We also need a way to propagate errors through potentially many layers
of recursion - perhaps even adding info at each pass step.
** TODO Can we make a better abstraction for environments?
[[file:include/obj.h::// Environments]]
An environment is an ALIST.  This is okay, but not great - O(n) time
to search stuff up.  Furthermore, _every_ time we set something, the
environment alist grows - this is bad for long term performance.

It makes lexical environments trivial, which is nice.  We need
something better though.
** TODO stream_init_cstr
[[file:include/parser.h]]
Create a new stream from a CString passed in.  Makes testing easier
and adds an avenue for better testing.
** TODO Write a better environment API
Environments are quite lax in how they're managed in the original
forsp codebase.  The global environment is managed as a general cons
list - when we define something on the environment, we cons a new cell
onto the environment.  So for example if we have ~env=((a 10) (b 20))~
and then we define ~a = 40~, we transform the environment to
~env=((a 40) (a 10) (b 20))~.

Subsequent lookups will get ~a~ first, so that's fine.  But the old
~a~ reference still exists!  Closures, in the old database, are built
around this lax management; lexical binding is as simple as taking a
pointer to the environment at point of creation.  Since subsequent
environment definitions won't mutate later cells, the environment of
any closure is secure.  However, this is incredibly wasteful and the
growth rate of memory here is ridiculous.  We can consider a
hypothetical program which:
1) generates a closure which utilises some cell ~a~
2) binds to ~a~
3) loop to (1)

This program will very quickly flood the environment with useless
cells and increase the memory footprint by an untold amount.

Therefore, we should really be doing the classical mutating approach:
set the cell for ~a~ to 40 at point of definition.  In order for
closures to still maintain their own environment, we should instead
generate a copy of the global environment at point of creation and
bind its lifetime to the lifetime of the closure.  This way we keep
the global environment separate from the lexical environment of a
closure.

*** TODO Consider binding dependency graphs
Stretch goal: generate a binding dependency graph of a closure at
point of creation.  This means we figure out exactly /what/ bindings a
closure utilises when creating it, and only generate an environment
with those bindings.  May require deep recursion as the bindings a
closure utilises may be dependent on other bindings in the
environment.  Something to look into
** TODO Memory Management :gc:
We need a better memory management scheme for our heap allocated
stuff.

We currently maintain a vector of allocated objects, which is appended
to every time we allocate something to the heap as part of our
~make_*~ functions.  This is all cleaned up in ~state_delete~, which
is only really called at the end of the runtime.  In practice, this
means we don't really do any proactive collection of memory - which
means the memory footprint of any user program will grow indefinitely
despite there being situations where we could reasonably clean memory.

I'd like to implement a tracing GC strategy, so-called mark/sweep:
- Consider all objects unmarked at the start of the procedure
- Mark all "root" objects (immediately accessible via the environment)
  then recursively mark any sub-objects of them
- Iterate through all unmarked objects and clean them

This way we'll only clean the objects that are actually accessible by
the program at any small time interval.
*** TODO Consider the structure for memory allocation
Our current memory allocation strategy just uses ~malloc~ at the point
of creation.  ~malloc~ is great and all, but it's also really slow.  I
think we should implement a custom allocator, such as an ~arena~.

Pros:
- Allows us to /defragment/ memory space to make lookups faster
- Less calls to ~malloc~
- Custom pointer type which we can tag effectively

Cons:
- Memory lookup is a bit more involved; we need to first reference our
  arena
*** TODO Consider how we select root objects to mark
This is deeply linked to how we manage our environments - particularly
for closures.  See [[*Environments][Environments]] for more.
